#ifndef CLUSTER_SET_DSSP_H
#define CLUSTER_SET_DSSP_H

#ifndef CLUSTER_SET_DSSP_OPERATING_MODES_H
#define CLUSTER_SET_DSSP_OPERATING_MODES_H


enum Сluster_set_DSSP_operating_mode
{
	COMMON_USAGE_CLUSTER_DSSP_SET_MODE,
	FILL_UP_MODEL_CLUSTER_SET_DSSP_MODE
} 
;
#endif

#include <vector>
#include <string>
#include <fstream>
#include <map>

#include "Single_cluster_record.h"

using namespace std;

class	Sheduler;

class	Zip_iteator;

class	Fragment_base_subtle;
class	Sane_metrics_DSSP;

class  Cluster_set_DSSP
{
public:
   ~Cluster_set_DSSP();
   Cluster_set_DSSP () {};

	Cluster_set_DSSP::Cluster_set_DSSP (
		const string & cluster_set_name_name,
		const string dssp_word,
		Сluster_set_DSSP_operating_mode run_mode);

	vector < vector <double> >  prepare_cluster_distance_matrix() ;
	
	vector <int>  algorithm_2 (
		double upper_dist,				
		double lower_dist,				
		double step_dist,				
		int waited_claster_number,
		string & metrics_mode);

	void regulate_choseen_index_subsample_version( // fills properties for subset made by zip_it_ selection
		const vector <int> & choosen_indexes,
		vector < Single_cluster_record > & claster_diversity,
		double & distance_scattering,
		double & quadrate_distance_scattering) ;

	void Cluster_set_DSSP::
	regulate_choseen_index_subsample_version_ALL_BASE (
		const vector <int> & choosen_indexes,
		vector < Single_cluster_record > & claster_diversity,
		double & distance_scattering,
		double & quadrate_distance_scattering) ;



	void plain_claster_show_subsample_version ( 
		const string & output_file_name,
		vector < Single_cluster_record > & claster_diversity,
		double & distance_scattering,
		double & quadrate_distance_scattering );

	void 	regulate_choseen_index( 
		const vector <int> & choosen_indexes,
		vector < Single_cluster_record > & claster_diversity,
		double & distance_scattering,
		double & quadrate_distance_scattering) ;

	void regulate_choseen_index_for_whole_base( //  choosen_indexes - relating to total ( not reduced base) !!!
	//	const vector <int> & choosen_indexes,
		vector < Single_cluster_record > & claster_diversity,
		double & distance_scattering,
		double & quadrate_distance_scattering) ;

	void plain_claster_show ( 
		const string & output_file_name,
		vector < Single_cluster_record > & claster_diversity,
		double & distance_scattering,
		double & quadrate_distance_scattering);

	void subtle_claster_show_for_whole_base ( 
 		const string & output_file_name,
		vector < Single_cluster_record > & claster_diversity );

	void	expand_clasterization_hystory_protocol ();

	void expand_clasterization_hystory_protocol (
		vector < Single_cluster_record > & claster_diversity,
		double & distance_scattering,
		double & quadrate_distance_scattering);

	bool raise_choosen_indexes 
		(const int			calculation_index,
		int					&	number_of_clasters,
		vector < int >		&	claster_index_in_base );

	void optimize_clasterization () ;

	void mutual_distance_for_BS_show ();

	void mutual_distance_for_BS_show ( 
		vector <int > & choosen_indexes,
		vector < vector <double> > & Cluster_distance_matrix);

// data for COMMON_USAGE_CLUSTER_SET_MODE runmode;	
	vector <int> get_claster_motif_index()  const {  return claster_motif_index_; }
	int number_of_classes() const {return number_of_classes_;} 
	int fragment_length  () const {return fragment_length_;};
	string get_sane_metrics_mame() const {return sane_metrics_mame_;} 
	string get_cluster_set_mame () const {return cluster_set_mame_;}

	double ** get_claster_motif_coordinates() const { return claster_motif_coordinates_;} ;

	Fragment_base_subtle	 * get_fragment_base() const {return fragment_base_;}

	string get_host_dir() const { return host_dir_;}

private:
		bool 	assign_best_parameters (
			double *distance_scattering_min,
			double *quadrate_distance_scattering_min,
			const string & protocol_file_name  );

		string cluster_set_mame_;

		string sane_metrics_mame_;
		string dssp_word_;

		vector <int> base_indexes_for_dssp_words_; // берется из  Sane_metrics_DSSP

		string host_dir_;					// директория содержащая Sane_metrics и там же все про текущие кластерные дела

		Sheduler		*sheduler_;	
		
		Fragment_base_subtle	 * fragment_base_;
		Sane_metrics_DSSP * sa_me_ ;
		
		Zip_iteator				*zip_it_;
		int						zip_factor_;
		int						shift_;

		int		subsample_size_;		// sample generated by zip_it_ has this size
		int		length_;

		double **subsample_fragments_;

		void warm_up_metrics( 
				double *metrics,
				const string &metrics_mode);

		map < int, int > zip_to_base_index_;

// data for COMMON_USAGE_CLUSTER_SET_MODE runmode;
		double **claster_motif_coordinates_;
		vector <int> claster_motif_index_;
		int number_of_classes_;
		int fragment_length_;

		void init_claster_motif();


		// possible

	string regulate_choseen_index_mode_;

	int total_fragment_number_ ; //= fragment_base_->get_total_fragment_number(); SIZE of fragment base
	double **all_BASE_fragments_; // all fragments from base

};

bool raise_choosen_indexes (
	const string		& name_claster_store,
	const int			  calculation_index,
	int					& number_of_clasters,
	vector < int >		& claster_index_in_base );

vector <int > pull_out_claster_origin_structure_list (
	const string & exact_path_to);

void  make_claster_origin_list_and_names (
	const string & path_to_protocol_store,
	const string & protocol_file,
	map < int, string > & cl_in_base_nu_to_dssp_word );

#endif

